<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
			body {
                margin: 0px;
            }
    </style>
</head>
<body>
    <div id="ThreeJS" target="_blank"></div>
    <script src="js/jquery.js"></script>
    <script src="js/three.js"></script>
    <script type="x-shader/x-vertex" id="feature_vsh">
        uniform float pointSize;
        varying vec3 v_color;
        void main() {
            v_color = color;
            gl_PointSize = pointSize;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="feature_fsh">
        varying vec3 v_color;
        void main() {
            float radius = distance(gl_PointCoord, vec2(0.5))*2.0; // dist from point centre, now in [0,1)
            if (radius < 0.8) {
                gl_FragColor = vec4(v_color, 1.0);
            } else if (radius <= 1.0) {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            } else {
                discard;
            }
        }
    </script>
    <script>
        var scene = new THREE.Scene();

        var renderer = new THREE.WebGLRenderer();
        var width = window.innerWidth;
        var height = window.innerHeight;
        var wndAspect = width / height;
        renderer.setSize( width, height );
        var container = document.getElementById("ThreeJS");
        container.appendChild(renderer.domElement);

        var url = {
            tracks: "http://localhost:8000/data/dartmoor-small/5/tracks.json",
            image: "http://localhost:8000/data/dartmoor-small/5/images/",
            reconstr: "http://localhost:8000/data/dartmoor-small/5/reconstruction.json"
        };

        var sequence = [];

        var Snapshot = function() {

        };

        var tracksToArray = function(tracks) {
            var arr = [];
            for (var tid in Object.keys(tracks)) {
                var obj = tracks[tid];
                obj.track_id = tid; // Transfer to obj
                arr.push(obj);
            }
            arr.sort(function(t1, t2) {
                return t1.track_id - t2.track_id;
            });
            return arr;
        };

        var intersectTrackArrays = function(t1, t2) { // identify elements that occur in both arrays; mark in t1
            var i1 = 0; // points to what we are currently considering within t1
            var i2 = 0; // likewise for t2


            var obj1 = t1[i1], obj2 = t2[i2];
            if (obj1.track_id === obj2.track_id) {
                t1.twin = t2;
                i1++;
            } else if (obj1.track_id < obj2.track_id) {
                if (i1 === t1.length-1) break;
                else i1++;
            } else {
                if (i2 === t2.length-1) break;
                else i2++;
            }
        };

        var snapshot; // = { name: 001.jpg, tracks: { 102: { ... }, 67: { ... }, ... } }
        var reconstr;
        var dims;

        var scale = 10;

        // Initialises geometry.
        // dataSource contains .nextTrack() which returns an object like
        // { coords: [x, y], color: [100, 200, 255] /* r,g,b */ }
        // or "done" when finished
        var FeatureCloud = function(dataSource) {
            var pointGeom = new THREE.Geometry();
            var track = dataSource.nextTrack();
            var z = 0.0;
            while (track !== "done") {
                var pos = track.coords;
                pointGeom.vertices.push(new THREE.Vector3(pos[0], pos[1], z*0.00001));
                var col = track.color;
                pointGeom.colors.push(new THREE.Color(col[0] / 255., col[1] / 255., col[2] / 255.));

                track = dataSource.nextTrack();
                z++;
            }
            if (FeatureCloud.prototype.material === undefined) {
                FeatureCloud.prototype.material = new THREE.ShaderMaterial({
                    vertexColors: THREE.VertexColors,
                    side: THREE.DoubleSide,
                    uniforms: {
                        pointSize: {type: 'f', value: 20.0},
                    },
                    vertexShader: $("#feature_vsh").text(),
                    fragmentShader: $("#feature_fsh").text(),
                });
            }

            this.threeObject = new THREE.PointCloud(pointGeom, FeatureCloud.prototype.material);

        };
        FeatureCloud.prototype = {};

        var ImageQuad = function(aspect, texture) {
            var geom = ImageQuad.prototype.geom;
            if (geom === undefined) {
                geom = new THREE.Geometry();
                ImageQuad.prototype.geom = geom;

                var dy = 0.5, dx = aspect * dy;

                geom.vertices.push(new THREE.Vector3(-dx, -dy, 0)); // bottom left
                geom.vertices.push(new THREE.Vector3(-dx, dy, 0)); // top left
                geom.vertices.push(new THREE.Vector3(dx, dy, 0)); // top right
                geom.vertices.push(new THREE.Vector3(dx, -dy, 0)); // bottom right

                geom.faces.push(new THREE.Face3(0, 2, 1));
                geom.faces.push(new THREE.Face3(0, 3, 2));

                geom.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
                geom.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);
            }
            var mat = new THREE.MeshBasicMaterial({ map: texture });

            this.threeObject = new THREE.Mesh(geom, mat);
        };
        ImageQuad.prototype = {};

        jQuery.when(jQuery.getJSON(url.tracks), jQuery.getJSON(url.reconstr)).done(function (tdata, rdata) {
            // jQuery seems to wrap results in random guff
            tdata = tdata[0]; rdata = rdata[0];
            snapshot = { name: "00000000.jpg" };
            snapshot.tracks = tdata[snapshot.name];

            snapshot.texture = THREE.ImageUtils.loadTexture(url.image+snapshot.name);

            reconstr = rdata[0];
            for (var prop in reconstr.cameras) { if (reconstr.cameras.hasOwnProperty(prop) && typeof prop === "string") {
                var cam = reconstr.cameras[prop];
                dims = [cam.width, cam.height];
                break; // Do the loop only once; use a **random camera** (usually there is only one, so ok...!)
            }}

            var aspect = dims[0] / dims[1];

            (function () {
                // *** Image quad ***

                var quad = new ImageQuad(aspect, snapshot.texture);
                var threeQuad = quad.threeObject;
                scene.add(threeQuad);

                threeQuad.position.copy(new THREE.Vector3(0, 0, -0.01));
                threeQuad.scale.multiplyScalar(10);

                // *** Swirly points ***

                var featureCloud = new FeatureCloud({ // iterate through snapshot.tracks
                    keys: Object.keys(snapshot.tracks), i: 0, nextTrack: function() {
                        if (this.i < this.keys.length) {
                            var key = this.keys[this.i];
                            this.i++;
                            return snapshot.tracks[key];
                        } else {
                            return "done";
                        }
                    }
                });

                featureCloud.threeObject.scale.set(1, -1, 1).multiplyScalar(aspect*10);
                featureCloud.threeObject.position.copy(new THREE.Vector3(0, 0, 0.01));
                scene.add(featureCloud.threeObject);
            })();

            // Fit camera to image, while keeping window aspect ratio
            var camWidth = 10*aspect, camHeight = 10; // image width, image height

            if (camWidth >= camHeight) {
                camHeight = camWidth / wndAspect; // keep view as wide as image, and stretch vertically
            } else {
                camWidth = camHeight * wndAspect; // keep view as tall as image, and stretch horizontally
            }

            var camera = new THREE.OrthographicCamera(-camWidth/2, camWidth/2, camHeight/2, -camHeight/2, 0.1, 1000);
            camera.position.z = 10;
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            scene.add(camera);

            var render = function () {
                renderer.render(scene, camera);
            };

            var events = {
                keyDown: function(event) {},
                keyUp: function(event) {},
                mouseDown: function(event) {},
                mouseUp: function(event) {},
                mouseMove: function(event) {},
                mouseWheel: function(event) {
                    event.preventDefault(); event.stopPropagation();

                    var zoom = event.deltaY;
                    if (zoom > 0) {
                        zoom = 1.1;
                    } else {
                        zoom = 0.9;
                    }
                    camera.scale.multiplyScalar(zoom);
                    render();
                }
            };
            renderer.domElement.addEventListener("mousemove", events.mouseMove, false);
            renderer.domElement.addEventListener("mousedown", events.mouseDown, false);
            renderer.domElement.addEventListener("mouseup", events.mouseUp, false);
            renderer.domElement.addEventListener("contextmenu", function ( event ) { event.preventDefault(); }, false );
            renderer.domElement.addEventListener("mousewheel", events.mouseWheel, false );
            renderer.domElement.addEventListener("keyup", events.keyUp, false );
            renderer.domElement.addEventListener("keydown", events.keyDown, false );

            // TODO: Simpler + more appropriate camera controls

            /*(function () {
                // *** Axis and grid ***
                var grid_group = new THREE.Object3D();

                var N = 20;
                var scale = 1;

                // Axis
                var axisgeo = new THREE.Geometry();
                var extent = scale * N;
                axisgeo.vertices = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(extent, 0, 0), // x
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, extent, 0), // y
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, extent) // z
                ];
                axisgeo.colors = [
                    new THREE.Color(0xff0000),
                    new THREE.Color(0xff0000),
                    new THREE.Color(0x00ff00),
                    new THREE.Color(0x00ff00),
                    new THREE.Color(0x0000ff),
                    new THREE.Color(0x0000ff)
                ];
                var lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    vertexColors: THREE.VertexColors
                });
                var line = new THREE.Line(axisgeo, lineMaterial, THREE.LinePieces);
                grid_group.add(line);

                // Grid
                var linegeo = new THREE.Geometry();
                // Picture this: x-axis goes left-to-right, y-axis bottom-to-top.
                for (var i = 0; i < 2 * N; ++i) {
                    if (i !== N) {
                        linegeo.vertices.push(
                            // Vertical line
                            new THREE.Vector3(scale * (i - N), scale * (-N), 0), // Bottom --
                            new THREE.Vector3(scale * (i - N), scale * ( N), 0), //        -- to top
                            // Horizontal line
                            new THREE.Vector3(scale * (-N), scale * (i - N), 0), // Left --
                            new THREE.Vector3(scale * ( N), scale * (i - N), 0)  //      -- to right
                        );
                    }
                }
                var lineMaterial = new THREE.LineBasicMaterial({color: 0x555555});
                var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                grid_group.add(line);
                scene.add(grid_group);
            })();*/

            render();
        });
    </script>
</body>
</html>