<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script>
        var scene = new THREE.Scene();

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
        camera.position.x = 50;
        camera.position.y = 50;
        camera.position.z = 50;
        camera.up = new THREE.Vector3(0, 0, 1);
        var controls = new THREE.OrbitControls(camera, renderer.domElement);

        // TODO: Simpler camera controls?

        (function() {
            // *** Wiggly function grid ***

            var geom = new THREE.Geometry();

            var f = function (x, y) {
                var cos = Math.cos;
                return 3 * cos(x / 2.0) * cos(y / 2.0);
            };

            var rowMemo = {}; // Contains (part of) previous row that is still needed
            for (var y = -10; y <= 10; y++) {
                var colMemo = undefined;
                for (var x = -10; x <= 10; x++) {
                    var z = f(x, y);
                    var vec = new THREE.Vector3(x, y, z);

                    // Vertical line from prev row to this one
                    if (typeof rowMemo[x] !== "undefined") {
                        geom.vertices.push(rowMemo[x]);
                        geom.vertices.push(vec);
                    }
                    rowMemo[x] = vec; // Update "prev" row
                    // Horizontal line from prev col to this one
                    if (typeof colMemo !== "undefined") {
                        geom.vertices.push(colMemo);
                        geom.vertices.push(vec);
                    }
                    colMemo = vec; // Update "prev" col
                }
            }

            var material = new THREE.LineBasicMaterial({color: 0x00ff00});
            var grid = new THREE.Line(geom, material, THREE.LinePieces);
            scene.add(grid);
        })();

        (function() {
            // *** Swirly points ***

            var pgeom = new THREE.Geometry();
            for (var i = 0; i < 30; i++) {
                var theta = i / 3.0;
                var r = theta;
                var x = r * Math.cos(theta);
                var y = r * Math.sin(theta);
                var z = 3;
                var vec = new THREE.Vector3(x, y, z);
                pgeom.vertices.push(vec);
            }

            var cloudMat = new THREE.PointCloudMaterial({size: 5, color: 0xffffff, sizeAttenuation: false});
            var cloud = new THREE.PointCloud(pgeom, cloudMat);
            scene.add(cloud);
        })();

        (function() {
            // *** Axis and grid ***
            var grid_group = new THREE.Object3D();

            var N = 20;
            var scale = 1;

            // Axis
            var axisgeo = new THREE.Geometry();
            var extent = scale * N;
            axisgeo.vertices = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(extent, 0, 0), // x
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, extent, 0), // y
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, extent) // z
            ];
            axisgeo.colors = [
                new THREE.Color(0xff0000),
                new THREE.Color(0xff0000),
                new THREE.Color(0x00ff00),
                new THREE.Color(0x00ff00),
                new THREE.Color(0x0000ff),
                new THREE.Color(0x0000ff)
            ];
            var lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                vertexColors: THREE.VertexColors
            });
            var line = new THREE.Line(axisgeo, lineMaterial, THREE.LinePieces);
            grid_group.add(line);

            // Grid
            var linegeo = new THREE.Geometry();
            // Picture this: x-axis goes left-to-right, y-axis bottom-to-top.
            for (var i = 0; i < 2 * N; ++i) {
                if (i !== N) {
                    linegeo.vertices.push(
                        // Vertical line
                        new THREE.Vector3(scale * (i - N), scale * (-N), 0), // Bottom --
                        new THREE.Vector3(scale * (i - N), scale * ( N), 0), //        -- to top
                        // Horizontal line
                        new THREE.Vector3(scale * (-N), scale * (i - N), 0), // Left --
                        new THREE.Vector3(scale * ( N), scale * (i - N), 0)  //      -- to right
                    );
                }
            }
            var lineMaterial = new THREE.LineBasicMaterial({color: 0x555555});
            var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
            grid_group.add(line);
            scene.add(grid_group);
        })();


        var render = function() {
            renderer.render(scene, camera);
        };

        controls.addEventListener('change', render);

        render();
    </script>
</body>
</html>