<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
			body {
                margin: 0px;
            }
    </style>
</head>
<body>
    <div id="ThreeJS" target="_blank"></div>
    <script src="js/jquery.js"></script>
    <script src="js/three.js"></script>
    <script type="x-shader/x-vertex" id="feature_vsh">
        uniform float pointSize;
        varying vec3 v_color;
        void main() {
            v_color = color;
            gl_PointSize = pointSize;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="feature_fsh">
        varying vec3 v_color;
        void main() {
            float radius = distance(gl_PointCoord, vec2(0.5))*2.0; // dist from point centre, now in [0,1)
            if (radius < 0.8) {
                gl_FragColor = vec4(v_color, 1.0);
            } else if (radius <= 1.0) {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            } else {
                discard;
            }
        }
    </script>
    <script>
        var scene = new THREE.Scene();

        var renderer = new THREE.WebGLRenderer();
        var width = window.innerWidth * 0.99;
        var height = window.innerHeight * 0.99;
        var wndAspect = width / height;
        renderer.setSize( width, height );
        var container = document.getElementById("ThreeJS");
        container.appendChild(renderer.domElement);

        var url = {
            tracks: "http://localhost:8000/data/dartmoor-small/5/tracks.json",
            image: "http://localhost:8000/data/dartmoor-small/5/images/",
            reconstr: "http://localhost:8000/data/dartmoor-small/5/reconstruction.json"
        };

        // adds "track_id" field to each track, returns new array sorted smallest-to-largest track_id
        var tracksToArray = function(tracks) {
            var arr = [];
            for (var tid in Object.keys(tracks)) {
                var obj = tracks[tid];
                if (obj !== undefined) {
                    obj.track_id = tid; // Transfer to obj
                    arr.push(obj);
                }
            }
            arr.sort(function(t1, t2) {
                return t1.track_id - t2.track_id;
            });
            return arr;
        };

        // identify elements that occur in both arrays; marked in t2 as <track>.twin
        // algorithm assumes arrays have been sorted smallest-to-largest
        var intersectTrackArrays = function(t1, t2) {
            var i1 = 0; // points to what we are currently considering within t1
            var i2 = 0; // likewise for t2

            while (i1 < t1.length && i2 < t2.length) {
                var obj1 = t1[i1], obj2 = t2[i2];

                if (obj1.track_id === obj2.track_id) {
                    obj2.twin = obj1; // mark
                    i1++; // if advanced i2++ as well, would skip duplicates. not sure about that
                } else if (obj1.track_id < obj2.track_id) {
                    if (i1 === t1.length - 1) break; // because i2 is sorted, no chance of a further match
                    else i1++;
                } else {
                    if (i2 === t2.length - 1) break; // likewise for i1
                    else i2++;
                }
            }
        };

        // Used from perspective of (member of tracks) "coming from" its twin.
        // i.e. twin comes first, then step forward to (member of tracks). Draw delta from former to latter.
        var calcDeltaGeom = function(tracks) {
            var geom = new THREE.Geometry();

            for (var i=0; i<tracks.length; i++) {
                var track = tracks[i];
                if (track.twin !== undefined) {
                    var p1 = track.coords, p2 = track.twin.coords;

                    geom.vertices.push(new THREE.Vector3(p2[0], p2[1], 0));
                    geom.vertices.push(new THREE.Vector3(p1[0], p1[1], 0));
                }
            }

            return geom;
        };

        var reconstr;

        var scale = 10;

        // Initialises geometry.
        // dataSource contains .nextTrack() which returns an object like
        // { coords: [x, y], color: [100, 200, 255] /* r,g,b */ }
        // or "done" when finished
        var FeatureCloud = function(dataSource) {
            var pointGeom = new THREE.Geometry();
            var track = dataSource.nextTrack();
            var z = 0.0;
            while (track !== "done") {
                var pos = track.coords;
                pointGeom.vertices.push(new THREE.Vector3(pos[0], pos[1], z*0.00001));
                var col = track.color;
                pointGeom.colors.push(new THREE.Color(col[0] / 255., col[1] / 255., col[2] / 255.));

                track = dataSource.nextTrack();
                z++;
            }
            if (FeatureCloud.prototype.material === undefined) {
                FeatureCloud.prototype.material = new THREE.ShaderMaterial({
                    vertexColors: THREE.VertexColors,
                    side: THREE.DoubleSide,
                    depthWrite: true,
                    uniforms: {
                        pointSize: {type: 'f', value: 20.0},
                    },
                    vertexShader: $("#feature_vsh").text(),
                    fragmentShader: $("#feature_fsh").text(),
                });
            }

            this.threeObject = new THREE.PointCloud(pointGeom, FeatureCloud.prototype.material);

        };
        FeatureCloud.prototype = {};

        var ImageQuad = function(aspect, texture) {
            var geom = new THREE.Geometry();

            var dy = 0.5, dx = aspect * dy;

            geom.vertices.push(new THREE.Vector3(-dx, -dy, 0)); // bottom left
            geom.vertices.push(new THREE.Vector3(-dx, dy, 0)); // top left
            geom.vertices.push(new THREE.Vector3(dx, dy, 0)); // top right
            geom.vertices.push(new THREE.Vector3(dx, -dy, 0)); // bottom right

            geom.faces.push(new THREE.Face3(0, 2, 1));
            geom.faces.push(new THREE.Face3(0, 3, 2));

            geom.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)]);
            geom.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1)]);

            var mat = new THREE.MeshBasicMaterial({ map: texture });

            this.threeObject = new THREE.Mesh(geom, mat);
        };
        ImageQuad.prototype = {};

        jQuery.when(jQuery.getJSON(url.tracks), jQuery.getJSON(url.reconstr)).done(function (tdata, rdata) {
            // jQuery seems to wrap results in random guff
            tdata = tdata[0]; rdata = rdata[0];
            // Pick reconstruction 0
            reconstr = rdata[0];

            var Snapshot = function(filename) {
                Snapshot.namesMap[filename] = this;

                var tracks = tdata[filename];
                var camera_name = reconstr.shots[filename].camera;
                var camera = reconstr.cameras[camera_name];
                var aspect = camera.width / camera.height;

                var threeObject = new THREE.Object3D();

                var texture = THREE.ImageUtils.loadTexture(url.image+filename);

                var quad = new ImageQuad(aspect, texture);
                threeObject.add(quad.threeObject);

                quad.threeObject.position.copy(new THREE.Vector3(0, 0, -0.01));
                quad.threeObject.scale.multiplyScalar(10);

                var featureCloud = new FeatureCloud({ // iterate through tracks
                    keys: Object.keys(tracks), i: 0, nextTrack: function() {
                        if (this.i < this.keys.length) {
                            var key = this.keys[this.i];
                            this.i++;
                            return tracks[key];
                        } else {
                            return "done";
                        }
                    }
                });

                featureCloud.threeObject.scale.set(1, -1, 1).multiplyScalar(aspect*10);
                //featureCloud.threeObject.position.copy(new THREE.Vector3(0, 0, 0));
                threeObject.add(featureCloud.threeObject);

                this.tracks = tracksToArray(tracks);

                if (Snapshot.prevCreated !== undefined) {
                    var prev = Snapshot.prevCreated;
                    this.prev = prev;
                    prev.next = this;

                    intersectTrackArrays(prev.tracks, this.tracks);
                    var geom = calcDeltaGeom(this.tracks);

                    var deltaMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                    var delta = new THREE.Line(geom, deltaMat, THREE.LinePieces);

                    delta.scale.set(1, -1, 1).multiplyScalar(aspect*10);
                    delta.position.copy(new THREE.Vector3(0, 0, 2));
                    threeObject.add(delta);
                }

                this.filename = filename;
                this.aspect = aspect;
                this.threeObject = threeObject;
                Snapshot.prevCreated = this;
            };
            Snapshot.namesMap = {};
            Snapshot.byFileName = function(filename) {
                return this.namesMap[filename];
            };

            var namesInOrder = Object.keys(reconstr.shots).sort(function(n1, n2) {
                n1 = +n1.substring(0, n1.length - 4); // no ".jpg", parse to int
                n2 = +n2.substring(0, n2.length - 4); // ditto
                return n1 - n2;
            });

            for (var i=0; i<namesInOrder.length; i++) { // Preload EVERYTHING!!
                var name = namesInOrder[i];
                new Snapshot(name);
            }

            var current = Snapshot.byFileName("00000000.jpg");
            scene.add(current.threeObject);

            // Fit camera to image, while keeping window aspect ratio
            var camWidth = 10*current.aspect, camHeight = 10; // image width, image height

            if (camWidth >= camHeight) {
                camHeight = camWidth / wndAspect; // keep view as wide as image, and stretch vertically
            } else {
                camWidth = camHeight * wndAspect; // keep view as tall as image, and stretch horizontally
            }

            var camera = new THREE.OrthographicCamera(-camWidth/2, camWidth/2, camHeight/2, -camHeight/2, 0.1, 1000);
            camera.position.z = 10;
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            scene.add(camera);

            var render = function () {
                renderer.render(scene, camera);
            };

            var changeSnapshot = function(newSnap) {
                if (newSnap === undefined) return;

                scene.remove(current.threeObject);
                scene.add(newSnap.threeObject);

                current = newSnap;
            };

            var events = {
                keyDown: function(event) {
                    switch (event.key) {
                        case "ArrowDown":
                            changeSnapshot(current.prev);
                            break;
                        case "ArrowUp":
                            changeSnapshot(current.next);
                            break;
                    }
                    render();
                },
                keyUp: function(event) {},
                mouseDown: function(event) {},
                mouseUp: function(event) {},
                mouseMove: function(event) {},
                mouseWheel: function(event) {
                    event.preventDefault(); event.stopPropagation();

                    var zoom = event.deltaY;
                    if (zoom > 0) {
                        zoom = 1.1;
                    } else {
                        zoom = 0.9;
                    }
                    camera.scale.multiplyScalar(zoom);
                    render();
                }
            };
            window.addEventListener("mousemove", events.mouseMove, false);
            window.addEventListener("mousedown", events.mouseDown, false);
            window.addEventListener("mouseup", events.mouseUp, false);
            window.addEventListener("contextmenu", function ( event ) { event.preventDefault(); }, false );
            window.addEventListener("mousewheel", events.mouseWheel, false );
            window.addEventListener("keyup", events.keyUp, false );
            window.addEventListener("keydown", events.keyDown, true );

            // TODO: Simpler + more appropriate camera controls

            /*(function () {
                // *** Axis and grid ***
                var grid_group = new THREE.Object3D();

                var N = 20;
                var scale = 1;

                // Axis
                var axisgeo = new THREE.Geometry();
                var extent = scale * N;
                axisgeo.vertices = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(extent, 0, 0), // x
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, extent, 0), // y
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, extent) // z
                ];
                axisgeo.colors = [
                    new THREE.Color(0xff0000),
                    new THREE.Color(0xff0000),
                    new THREE.Color(0x00ff00),
                    new THREE.Color(0x00ff00),
                    new THREE.Color(0x0000ff),
                    new THREE.Color(0x0000ff)
                ];
                var lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    vertexColors: THREE.VertexColors
                });
                var line = new THREE.Line(axisgeo, lineMaterial, THREE.LinePieces);
                grid_group.add(line);

                // Grid
                var linegeo = new THREE.Geometry();
                // Picture this: x-axis goes left-to-right, y-axis bottom-to-top.
                for (var i = 0; i < 2 * N; ++i) {
                    if (i !== N) {
                        linegeo.vertices.push(
                            // Vertical line
                            new THREE.Vector3(scale * (i - N), scale * (-N), 0), // Bottom --
                            new THREE.Vector3(scale * (i - N), scale * ( N), 0), //        -- to top
                            // Horizontal line
                            new THREE.Vector3(scale * (-N), scale * (i - N), 0), // Left --
                            new THREE.Vector3(scale * ( N), scale * (i - N), 0)  //      -- to right
                        );
                    }
                }
                var lineMaterial = new THREE.LineBasicMaterial({color: 0x555555});
                var line = new THREE.Line(linegeo, lineMaterial, THREE.LinePieces);
                grid_group.add(line);
                scene.add(grid_group);
            })();*/

            render();
        });
    </script>
</body>
</html>